# 视频混剪工具工作原理

## 核心概念

该软件是一个**批量视频混剪工具**，能够从素材文件夹中自动选择视频片段，添加转场效果和背景音乐，生成完整的视频作品。

> **难点说明**：该软件对于文件结构的理解是比较复杂的，下面详细说明。

## 文件结构

不同的场景（也就是分步文件夹），里面都有对应场景的配音和视频，文件夹架构如下：

```
素材文件夹/
├── 场景1/              # 场景文件夹（按名称排序）
│   ├── 视频/           # 视频文件夹
│   │   ├── video1.mp4（本体）
│   │   └── video2.mp4（本体）
│   └── 配音/           # 配音文件夹
│       └── audio1.mp3（本体）
├── 场景2/（本体或快捷方式）
│   ├── 视频/（本体或快捷方式）
│   │   ├── video3.mp4（本体）
│   │   └── video4.mp4（本体）
│   └── 配音/（本体或快捷方式）
│       └── audio2.mp3（本体）
│       └── audio3.mp3（本体）
├── 场景3/              # 场景文件夹
│   ├── 视频/           # 视频文件夹
│   │   ├── video5.mp4（本体）
│   │   └── video6.mp4（本体）
│   └── 配音/           # 配音文件夹
│       └── audio5.mp3（本体）
```

**定义说明**：
- **素材文件夹**是父文件夹
- **场景**是子文件夹
- **视频**和**配音**是孙文件夹

> **注意**：子文件夹可以是实体也可以是快捷方式，包括名为【视频】或者【配音】的孙文件夹也可以是实体或快捷方式。在扫描阶段都能够识别。不会出现孙文件夹是快捷方式同时子文件夹也是快捷方式的情况。

孙文件夹的视频是待抽取的视频素材（通常一个孙文件夹的视频素材含有**500个以上**）。

## 工作模式

每个子文件夹（场景）都支持两种主要的工作模式：

1. **单视频模式**：从该场景下的视频素材中，随机选择一个足够长的视频
2. **多视频拼接模式**：从该场景下的视频素材中，随机选择多个短视频拼接以满足配音长度

---

## 处理流程

### 1. 【扫描阶段】

在扫描阶段，不需要把每一个视频都进行 FFprobe 调用去读取元数据，主要是扫描文件夹里面的视频或者配音的路径和视频时长等基础信息即可。

**要点**：
- 第一波的扫描需要记录和输出的信息是**所有视频和配音的时长的文本文件**
- 使用的是Windows自带的属性信息来获取视频时长
- **永远不要从文件名中解析**，更不是修改时长

记录格式示例：

```
===== 视频与音频时长信息 =====

扫描时间: 2025-05-20 20:52:47

[场景 1] 1、我给你讲个故事
----------------------------------------
视频文件:
  - 视频1.mp4: 00:01:30 (90.00秒)
  - 视频2.mp4: 00:02:10 (130.00秒)
  ...

音频文件:
  - 新分贝音量.MP3: 00:00:02 (2.40秒)

[场景 2] ...
...

===== 统计信息 =====
总场景数: 17
总视频数: 2435
总音频数: 17
```

> **优化说明**：一开始只读取基础文本信息（如路径，时长），把这个父文件夹里的所有素材的文本信息记录在缓存文件当中，这样即使是上万个素材，仅仅是文本的形式也不会占用太多的内存。

### 2. 【抽取+裁剪阶段】

#### 抽取逻辑

##### 单视频模式

1. 先用代码确定该子文件夹（场景）下需要多长的时长（即配音时长）
2. 分场景扫描孙文件夹里的配音，确定对应子文件夹（场景）的配音时长
3. 如果一个孙文件夹下面有多个配音，则需要先随机抽取一个配音作为该场景下时长参考（这个抽取的随机配音作为最终的配音）
4. **单视频模式下，只抽取视频时长大于配音的视频**（这是关键筛选机制）
5. 把选中的视频文件路径加入待处理队列当中
6. 再只对选中的视频用ffmeg去进行最简单的裁剪时长（能不解码尽量不解码，以免损失视频质量）（注意，这里裁剪的时长是配音的时长+0.1s作为缓冲）

##### 多视频模式

1. 在抽取之前新增一个计算时长的代码，先确定配音时长，然后在扫描阶段里得出来的缓存文件当中进行素材选取，随机抽取多个视频，例如c是3s，d是3s，e是3s，f是5s，g是6s等等，让这些视频素材时长满足该子文件夹的配音时长，计算多个视频的总时长，直到大于配音时长
2. 把选中的视频文件路径加入待处理队列当中
3. 对这些视频进行随机组合，快速拼接再裁剪最后一个视频，**而不是把3s剪辑到6s**
4. 使用FFmpeg的"concat demuxer"方法，直接拼接视频而不重新编码
5. 仅仅对最后一个孙视频进行简单的时长裁剪，以便该多视频拼接的时长刚好等于该子文件夹的配音的时长+0.1s作为缓冲

> **重要**：
> - **避免定格问题**：当选择的视频总时长不足以匹配配音时长时，系统请不要使用 -t 参数将视频延长至配音长度，这会导致 FFmpeg 将最后一帧静止保持到指定时长结束，造成视频定格。
> - **单视频模式**下，当视频时长不足配音时长时，就不选择这个视频，而是一开始就筛选时长够的视频。
> - **多视频模式**下，当随机选择的视频总时长超过配音时长后，代码尝试裁剪最后一个视频，但如果最后一个视频时长不足就再加视频，不要试图延长短的视频，这会导致视频定格，我的建议是多视频模式下也新加一条判断，一开始抽取的多个视频的时长总和要略大于配音时长，这样裁剪的时候就不会出现定格的问题。更不需要再额外加视频因为多视频的总时长已经大于配音时长。  
> - **抽取逻辑**，先点名，再处理，根据文本记录的时长去抽取视频，确定了要处理谁之后，再进行真正的处理

#### 关键改进

1. **单视频模式下不再选择时长不足的视频**：
   - 修改了 _get_random_video 方法，使其只选择时长大于或等于配音时长多0.1s的视频
   - 当没有足够长的视频时，返回 None，让调用者可以切换到多视频模式

2. **多视频模式下不再循环使用同一视频**：
   - 当最后一个视频时长不足时，不再循环播放该视频
   - 而是从所有可用视频中随机选择新的视频进行拼接
   - 如果所有视频都已被选择，会重新启用所有视频
   - 最后一个额外添加的视频会被适当裁剪，确保总时长比匹配配音多0.1s做缓冲

### 3. 【合成阶段】

1. 将所有子文件夹输出的视频按顺序，用FFmpeg的"concat demuxer"方法，直接拼接视频而不重新编码
2. 快速拼接成为父文件夹的输出视频
3. **背景音乐是在这一步进行处理的，配音是在上一步处理的**
4. 最终视频时长应约等于所有子文件夹所选出的配音的总时长（不是所有配音，而是所有被抽选上的配音）

---

## 处理细节补充

- 每个子视频场景下留了**0.1s作为缓冲**（不管是多视频还是单视频模式），也就是说视频比配音长0.1s以避免卡顿
- 配音是融合到对应的场景视频里面的，再去拼接成总视频
- 这样的好处在于，哪怕是有0.1s作为缓冲，那么我们所有的场景则是：配音1+0.1s（留白）+配音2+0.1s（留白）等等，听起来不会违和
- 而不是单独把所有的配音都先合并再和视频合并

## 三个阶段的逻辑关系

1. **扫描阶段**进行全部扫描，然后存在缓存文件当中。如果这次任务需要合成十个视频，需要扫描1次，如果这次任务需要合成十个视频，那也只需要扫描一次就够。

2. **抽取+裁剪阶段**从刚刚全部列出的信息当中进行抽取，如果这次任务需要合成十个视频，那么需要循环十遍抽取逻辑。如果有水印的话，那么水印在抽取这个阶段就加上，配音是这一步加到对应场景视频里的。

3. **合成逻辑**如果需要合成十个视频，那么需要循环十遍，把子视频拼接起来这个逻辑。最后的合成只需要速拼，不要重新编码，背景音乐是这一步加在大合集里的。





