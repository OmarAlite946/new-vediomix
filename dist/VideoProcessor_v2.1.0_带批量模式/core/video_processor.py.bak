#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
视频处理核心模块
"""

import os
import time
import random
import shutil
import subprocess
import threading
import re
from pathlib import Path
from concurrent.futures import ThreadPoolExecutor
from typing import List, Dict, Any, Optional, Tuple, Callable, Set, Union
import uuid
import datetime
import logging
import sys
import json
import gc
import tempfile
import traceback

# 添加项目根目录到 Python 路径
project_root = Path(__file__).resolve().parent.parent.parent
if str(project_root) not in sys.path:
    sys.path.insert(0, str(project_root))

try:
    import cv2
    import numpy as np
    from moviepy.editor import VideoFileClip, AudioFileClip, CompositeVideoClip, concatenate_videoclips, vfx, CompositeAudioClip
except ImportError as e:
    print(f"正在安装必要的依赖...")
    try:
        import pip
        pip.main(["install", "moviepy", "opencv-python", "numpy"])
        import cv2
        import numpy as np
        from moviepy.editor import VideoFileClip, AudioFileClip, CompositeVideoClip, concatenate_videoclips, vfx, CompositeAudioClip
    except Exception as install_error:
        print(f"安装依赖失败: {install_error}")
        print("请手动安装依赖：")
        print("pip install moviepy opencv-python numpy")
        sys.exit(1)

from src.utils.logger import get_logger
from src.utils.cache_config import CacheConfig

logger = get_logger()

class VideoProcessor:
    """视频处理核心类"""
    
    def __init__(self, settings: Dict[str, Any] = None, progress_callback: Callable[[str, float], None] = None):
        """
        初始化视频处理器
        
        Args:
            settings: 处理设置参数
            progress_callback: 进度回调函数，参数为(状态消息, 进度百分比)
        """
        # 初始化设置
        self.settings = settings if settings else {}
        self.progress_callback = progress_callback
        self.stop_requested = False
        self.temp_files = []
        self.start_time = 0
        
        # 进度更新定时器
        self._progress_timer = None
        self._last_progress_message = ""
        self._last_progress_percent = 0
        
        # 批量合成进度跟踪
        self._total_videos = 0
        self._completed_videos = 0
        
        # 初始化日志
        global logger
        self.logger = logger  # 将全局logger赋值给实例变量
        if not logger:
            logger = logging.getLogger("VideoProcessor")
            self.logger = logger
        
        # 检查FFmpeg
        self._check_ffmpeg()
        
        # 获取缓存配置
        cache_config = CacheConfig()
        cache_dir = cache_config.get_cache_dir()
        
        # 默认设置
        self.default_settings = {
            "hardware_accel": "auto",  # 硬件加速：auto, cuda, qsv, amf, none
            "encoder": "libx264",       # 视频编码器
            "resolution": "1080p",      # 输出分辨率
            "bitrate": 5000,            # 比特率(kbps)
            "threads": 4,               # 处理线程数
            "transition": "random",     # 转场效果: random, mirror_flip, hue_shift, ...
            "transition_duration": 0.5,  # 转场时长(秒)
            "voice_volume": 1.0,        # 配音音量
            "bgm_volume": 0.5,          # 背景音乐音量
            "output_format": "mp4",     # 输出格式
            "temp_dir": cache_dir,      # 使用配置的缓存目录
            # 添加水印相关默认设置
            "watermark_enabled": False,  # 水印功能默认关闭
            "watermark_prefix": "",      # 默认无自定义前缀
            "watermark_size": 24,        # 默认字体大小24像素
            "watermark_color": "#FFFFFF", # 默认白色
            "watermark_position": "右上角", # 默认位置在右上角
            "watermark_pos_x": 0,        # 默认X轴位置修正
            "watermark_pos_y": 0,         # 默认Y轴位置修正
            # 添加视频模式设置
            "video_mode": "",           # 视频处理模式: standard_mode(重编码), fast_mode(不重编码)
            "fast_scan_mode": True,     # 快速扫描模式: 不读取视频元数据，加快扫描速度
            "extreme_fast_mode": False  # 极简扫描模式: 只收集文件路径，不创建元数据对象
        }
        
        # 更新设置
        self.settings = self.default_settings.copy()
        if settings:
            # 保留原始temp_dir设置
            original_temp_dir = self.default_settings["temp_dir"]
            # 更新所有设置
            self.settings.update(settings)
            # 如果settings中没有提供temp_dir，使用默认的缓存目录
            if "temp_dir" not in settings:
                self.settings["temp_dir"] = original_temp_dir
        
        # 确保临时目录存在
        os.makedirs(self.settings["temp_dir"], exist_ok=True)
        
        # 初始化随机数生成器
        random.seed(time.time())
    
    def _check_ffmpeg(self) -> bool:
        """
        检查FFmpeg是否可用
        
        Returns:
            bool: 是否可用
        """
        ffmpeg_cmd = "ffmpeg"
        ffmpeg_path_file = None
        
        # 尝试从ffmpeg_path.txt读取自定义路径
        try:
            # 获取项目根目录
            project_root = Path(__file__).resolve().parent.parent.parent
            ffmpeg_path_file = project_root / "ffmpeg_path.txt"
            
            if ffmpeg_path_file.exists():
                with open(ffmpeg_path_file, 'r', encoding="utf-8") as f:
                    custom_path = f.read().strip()
                    if custom_path and os.path.exists(custom_path):
                        logger.info(f"使用自定义FFmpeg路径: {custom_path}")
                        ffmpeg_cmd = custom_path
                    else:
                        logger.warning(f"自定义FFmpeg路径无效或不存在: {custom_path}")
        except Exception as e:
            logger.error(f"读取自定义FFmpeg路径时出错: {str(e)}")
        
        try:
            # 尝试执行ffmpeg命令
            logger.info(f"正在检查FFmpeg: {ffmpeg_cmd}")
            result = subprocess.run(
                [ffmpeg_cmd, "-version"], 
                stdout=subprocess.PIPE, 
                stderr=subprocess.PIPE,
                text=True,
                timeout=5  # 增加超时时间
            )
            
            if result.returncode == 0:
                version_info = result.stdout.splitlines()[0] if result.stdout else "未知版本"
                logger.info(f"FFmpeg可用，版本信息：{version_info}")
                
                # 检查编码器支持
                try:
                    encoders_result = subprocess.run(
                        [ffmpeg_cmd, "-encoders"],
                        stdout=subprocess.PIPE,
                        stderr=subprocess.PIPE,
                        text=True,
                        timeout=5
                    )
                    
                    if encoders_result.returncode == 0:
                        encoders_output = encoders_result.stdout
                        # 检查硬件加速编码器
                        hw_encoders = []
                        for encoder in ["nvenc", "qsv", "amf", "vaapi"]:
                            if encoder in encoders_output:
                                hw_encoders.append(encoder)
                        
                        if hw_encoders:
                            logger.info(f"检测到支持的硬件加速编码器: {', '.join(hw_encoders)}")
                        else:
                            logger.info("未检测到支持的硬件加速编码器")
                except Exception as e:
                    logger.warning(f"检查编码器支持时出错: {str(e)}")
                
                return True
            else:
                error_detail = f"返回码: {result.returncode}, 错误: {result.stderr}"
                logger.error(f"FFmpeg不可用: {error_detail}")
                return False
        except FileNotFoundError:
            if ffmpeg_path_file and ffmpeg_path_file.exists():
                error_msg = f"自定义FFmpeg路径不正确，请重新配置。路径: {ffmpeg_cmd}"
            else:
                error_msg = "FFmpeg不在系统路径中，请安装FFmpeg并确保可以在命令行中使用，或使用配置路径功能"
            logger.error(error_msg)
            return False
        except PermissionError:
            logger.error(f"没有执行FFmpeg的权限: {ffmpeg_cmd}")
            return False
        except subprocess.TimeoutExpired:
            logger.error(f"检查FFmpeg超时，可能系统资源不足或FFmpeg无响应")
            return False
        except Exception as e:
            logger.error(f"检查FFmpeg时出错: {str(e)}, 类型: {type(e).__name__}")
            return False
    
    def _format_time(self, seconds):
        """
        将秒数格式化为时:分:秒格式
        
        Args:
            seconds: 秒数
            
        Returns:
            str: 格式化后的时间字符串 (HH:MM:SS)
        """
        hours = int(seconds // 3600)
        minutes = int((seconds % 3600) // 60)
        seconds = int(seconds % 60)
        return f"{hours:02d}:{minutes:02d}:{seconds:02d}"
    
    def report_progress(self, message: str, percent: float):
        """
        报告进度
        
        Args:
            message: 状态消息
            percent: 进度百分比 (0-100)
        """
        if self.progress_callback:
            try:
                # 如果处理已经开始，添加已用时间
                if self.start_time > 0:
                    elapsed_time = time.time() - self.start_time
                    elapsed_str = self._format_time(elapsed_time)
                    # 如果有设置合成总数，显示已合成数量
                    if self._total_videos > 0:
                        message = f"{message} (已用时: {elapsed_str}, 已合成: {self._completed_videos}/{self._total_videos})"
                    else:
                        message = f"{message} (已用时: {elapsed_str})"
                
                # 保存最后一次进度信息，用于定时器重发
                self._last_progress_message = message
                self._last_progress_percent = percent
                
                # 进度更新应该在主线程中进行
                # 这个回调通常是通过Qt的信号槽机制连接的，
                # 它会自动处理跨线程调用
                self.progress_callback(message, percent)
            except Exception as e:
                logger.error(f"调用进度回调时出错: {str(e)}")
        
        logger.info(f"进度 {percent:.1f}%: {message}")
    
    def get_last_progress(self) -> Optional[Tuple[str, float]]:
        """
        获取最后一次进度更新的消息和百分比
        
        Returns:
            Tuple[str, float] 或 None: 最后进度消息和百分比的元组，如果没有则返回None
        """
        if not self._last_progress_message:
            return None
        
        return (self._last_progress_message, self._last_progress_percent)
    
    def _start_progress_timer(self):
        """启动定期进度更新定时器，防止批处理模式中的超时检测"""
        if self._progress_timer is not None:
            return  # 已有定时器在运行
            
        def _timer_func():
            while not self.stop_requested:
                try:
                    # 每15秒重发一次最后的进度信息
                    if self._last_progress_message and self.progress_callback:
                        # 重新添加时间信息
                        if self.start_time > 0:
                            elapsed_time = time.time() - self.start_time
                            elapsed_str = self._format_time(elapsed_time)
                            base_message = self._last_progress_message.split('(已用时:')[0].strip()
                            # 如果有设置合成总数，显示已合成数量
                            if self._total_videos > 0:
                                message = f"{base_message} (已用时: {elapsed_str}, 已合成: {self._completed_videos}/{self._total_videos})"
                            else:
                                message = f"{base_message} (已用时: {elapsed_str})"
                            self.progress_callback(message, self._last_progress_percent)
                            logger.debug(f"定时重发进度: {self._last_progress_percent:.1f}%: {message}")
                except Exception as e:
                    logger.error(f"进度定时器错误: {str(e)}")
                
                # 睡眠15秒
                time.sleep(15)
        
        # 创建并启动定时器线程
        self._progress_timer = threading.Thread(target=_timer_func, daemon=True)
        self._progress_timer.start()
        logger.info("已启动进度定时更新")
    
    def _stop_progress_timer(self):
        """停止定期进度更新定时器"""
        # 因为是守护线程，不需要显式终止
        self._progress_timer = None
    
    def process_batch(self, 
                      material_folders: List[Dict[str, Any]], 
                      output_dir: str, 
                      count: int = 1, 
                      bgm_path: str = None) -> Tuple[List[str], str]:
        """
        批量处理视频
        
        Args:
            material_folders: 素材文件夹信息列表
            output_dir: 输出目录
            count: 要生成的视频数量
            bgm_path: 背景音乐路径
            
        Returns:
            Tuple[List[str], str]: 生成的视频文件路径列表和总用时
        """
        self.stop_requested = False
        output_videos = []
        
        # 开始计时
        self.start_time = time.time()
        
        # 设置要合成的视频总数 - 在极简模式下总是生成一个视频
        extreme_fast_mode = self.settings.get("extreme_fast_mode", False)
        if extreme_fast_mode:
            # 极简模式下强制只生成一个混剪视频
            self._total_videos = 1
            count = 1
        else:
        self._total_videos = count
        
        self._completed_videos = 0
        
        # 扫描素材文件夹
        self.report_progress("开始扫描素材文件夹...", 0)
        
        try:
            material_data = self._scan_material_folders(material_folders)
        except Exception as e:
            logger.error(f"扫描素材文件夹失败: {str(e)}")
            raise
        
        # 检查是否找到素材
        if not material_data:
            error_msg = "没有找到可用的素材文件"
            logger.error(error_msg)
            raise ValueError(error_msg)
        
        # 检查每个文件夹是否有视频
        for folder_name, data in material_data.items():
            if not data.get("videos", []) and not data.get("video_paths", []):
                logger.warning(f"场景 '{folder_name}' 中没有找到视频文件")
        
        self.report_progress("素材扫描完成，开始生成视频...", 5)
        
        # 生成多个视频
        output_videos = []
        
        # 添加当前时间戳到文件名，避免覆盖之前的文件
        timestamp = time.strftime("%Y%m%d_%H%M%S")
        
        # 在极简模式下，必须使用跨文件夹混剪模式
        if extreme_fast_mode:
            logger.info("启用极简混剪模式 - 汇总所有预选视频进行混剪")
            # 收集所有预选的多视频
            all_preselected_multi_videos = []
            all_preselected_videos = []  # 收集所有视频（包括单视频预选）
            all_preselected_audio = None
            preselected_folders = []
            
            # 遍历所有素材文件夹，收集预选视频和音频
            for segment_key, segment_data in material_data.items():
                # 收集多视频预选结果
                if segment_data.get("preselected_multi_videos"):
                    valid_videos = []
                    for video_path in segment_data.get("preselected_multi_videos", []):
                        if os.path.exists(video_path) and os.path.getsize(video_path) > 1000:
                            valid_videos.append(video_path)
                            all_preselected_videos.append(video_path)
                    
                    if valid_videos:
                        all_preselected_multi_videos.extend(valid_videos)
                        preselected_folders.append(segment_key)
                        logger.info(f"从文件夹 '{segment_key}' 收集到 {len(valid_videos)} 个有效预选视频")
                
                # 收集单视频预选结果
                if segment_data.get("preselected_video"):
                    video_path = segment_data.get("preselected_video")
                    if os.path.exists(video_path) and os.path.getsize(video_path) > 1000:
                        all_preselected_videos.append(video_path)
                        preselected_folders.append(segment_key)
                        logger.info(f"从文件夹 '{segment_key}' 收集到单个预选视频: {os.path.basename(video_path)}")
                
                # 收集预选音频
                if segment_data.get("preselected_audio") and not all_preselected_audio:
                    audio_path = segment_data.get("preselected_audio")
                    if os.path.exists(audio_path) and os.path.getsize(audio_path) > 1000:
                        all_preselected_audio = audio_path
                        logger.info(f"使用文件夹 '{segment_key}' 的预选音频: {os.path.basename(audio_path)}")
            
            # 确定要使用的视频列表
            videos_to_mix = []
            
            # 优先使用多视频预选结果（至少2个视频才能混剪）
            if len(all_preselected_multi_videos) >= 2:
                videos_to_mix = all_preselected_multi_videos
                logger.info(f"将使用多视频预选模式的 {len(videos_to_mix)} 个视频进行混剪")
            # 如果没有足够的多视频预选结果，但有足够的单视频预选结果
            elif len(all_preselected_videos) >= 2:
                videos_to_mix = all_preselected_videos
                logger.info(f"将使用所有预选视频（包括单视频） {len(videos_to_mix)} 个进行混剪")
            
            # 如果收集到了足够的预选视频，进行合并处理
            if len(videos_to_mix) >= 2:
                logger.info(f"极简模式: 从所有文件夹收集到 {len(videos_to_mix)} 个预选视频，进行混剪")
                
                # 随机打乱视频顺序
                random.shuffle(videos_to_mix)
                
                # 使用全部预选视频，不设数量上限，以生成更长的混剪视频
                logger.info(f"将使用全部 {len(videos_to_mix)} 个预选视频，以生成更长的混剪视频")
                
                # 限制使用的视频数量（如果视频太多）
                max_videos = 50  # 设置合理的上限
                if len(videos_to_mix) > max_videos:
                    videos_to_mix = videos_to_mix[:max_videos]
                    logger.info(f"限制预选视频数量为 {max_videos} 个，以确保处理效率")
                
                # 构建输出文件路径
                output_filename = f"混剪视频_{timestamp}.mp4"
                output_path = os.path.join(output_dir, output_filename)
                
                # 记录要使用的预选视频
                logger.info(f"将使用 {len(videos_to_mix)} 个预选视频进行混剪:")
                for i, video_path in enumerate(videos_to_mix[:5]):
                    logger.info(f"  预选视频 {i+1}: {os.path.basename(video_path)}")
                if len(videos_to_mix) > 5:
                    logger.info(f"  ... 及其他 {len(videos_to_mix)-5} 个视频")
                
                # 设置进度报告
                self.report_progress(f"正在生成混剪视频，使用 {len(videos_to_mix)} 个预选视频...", 10)
                
                try:
                    # 确保输出目录存在
                    os.makedirs(output_dir, exist_ok=True)
                    
                    # 使用FFmpeg直接拼接所有预选视频
                    success = self._concat_videos_with_ffmpeg(
                        videos_to_mix,
                        all_preselected_audio,
                        output_path,
                        skip_metadata=True
                    )
                    
                    if success:
                        logger.info(f"成功混剪 {len(videos_to_mix)} 个预选视频")
                        
                        # 如果有背景音乐，添加背景音乐
                        if bgm_path and os.path.exists(bgm_path):
                            self.report_progress("正在添加背景音乐...", 70)
                            try:
                                self._add_bgm_to_video(output_path, bgm_path)
                                logger.info("成功添加背景音乐")
                            except Exception as e:
                                logger.warning(f"添加背景音乐失败: {str(e)}")
                        
                        # 添加水印（如果启用）
                        if self.settings.get("watermark_enabled", False):
                            self.report_progress("正在添加水印...", 85)
                            try:
                                watermarked_path = self._create_temp_file("watermarked", ".mp4")
                                if self._add_watermark_to_video(output_path, watermarked_path):
                                    # 替换原文件
                                    shutil.move(watermarked_path, output_path)
                                    logger.info("成功添加水印")
                                else:
                                    logger.warning("添加水印失败，保留原始视频")
                            except Exception as e:
                                logger.warning(f"添加水印失败: {str(e)}")
                        
                        # 添加到输出列表
                        output_videos.append(output_path)
                        self._completed_videos += 1
                        
                        # 计算总用时
                        total_time = time.time() - self.start_time
                        total_time_str = self._format_time(total_time)
                        
                        self.report_progress(f"混剪视频处理完成，总用时: {total_time_str}", 100)
                        logger.info(f"混剪视频处理完成，总用时: {total_time_str}")
                        
                        return output_videos, total_time_str
                    else:
                        logger.error("跨文件夹混剪视频处理失败，尝试单个文件夹处理")
                        # 继续执行单个文件夹处理
                except Exception as e:
                    logger.error(f"跨文件夹混剪视频处理过程中出错: {str(e)}")
                    logger.error(f"尝试单个文件夹处理")
            else:
                logger.warning("没有足够的预选视频进行混剪（至少需要2个视频），将使用标准处理模式")
        
        # 标准模式处理（或极简模式但没有足够的预选视频）
        # 计算每个视频的进度百分比
        progress_per_video = 90.0 / count if count > 0 else 0
        
        # 强制在极简模式下只处理一个视频
        for i in range(count):
            if self.stop_requested:
                logger.info("收到停止请求，中断视频批量处理")
                break
            
            # 构建输出文件路径
            if extreme_fast_mode:
                output_filename = f"混剪视频_{timestamp}.mp4"
            else:
            output_filename = f"合成视频_{timestamp}_{i+1}.mp4"
            output_path = os.path.join(output_dir, output_filename)
            
            # 设置该视频的进度范围
            progress_start = 5 + i * progress_per_video
            progress_end = 5 + (i + 1) * progress_per_video
            
            if extreme_fast_mode:
                self.report_progress(f"正在生成混剪视频...", progress_start)
            else:
            self.report_progress(f"正在生成第 {i+1}/{count} 个视频...", progress_start)
            
            try:
                # 处理单个视频
                result_path = self._process_single_video(
                    material_data, 
                    output_path, 
                    bgm_path,
                    progress_start,
                    progress_end
                )
                
                output_videos.append(result_path)
                # 更新已完成视频数量
                self._completed_videos += 1
                
                if extreme_fast_mode:
                    logger.info(f"混剪视频生成完成: {result_path}")
                else:
                logger.info(f"第 {i+1}/{count} 个视频生成完成: {result_path}")
                    
                # 在极简模式下，只生成一个视频，立即退出循环
                if extreme_fast_mode:
                    break
            except Exception as e:
                if extreme_fast_mode:
                    logger.error(f"生成混剪视频时出错: {str(e)}")
                    raise  # 在极简模式下，出错就终止
                else:
                logger.error(f"生成第 {i+1}/{count} 个视频时出错: {str(e)}")
                # 继续处理下一个视频
                continue
        
        # 计算总用时
        total_time = time.time() - self.start_time
        total_time_str = self._format_time(total_time)
        
        if extreme_fast_mode:
            self.report_progress(f"混剪视频处理完成，总用时: {total_time_str}", 100)
            logger.info(f"混剪视频处理完成，总用时: {total_time_str}")
        else:
        self.report_progress(f"批量视频处理完成，成功生成: {len(output_videos)}/{count}，总用时: {total_time_str}", 100)
        logger.info(f"批量视频处理完成，成功生成: {len(output_videos)}/{count}，总用时: {total_time_str}")
        
        return output_videos, total_time_str
    
    def stop_processing(self):
        """停止处理"""
        self.stop_requested = True
        logger.info("已请求停止视频处理")
    
    def _scan_material_folders(self, material_folders: List[Dict[str, Any]]) -> Dict[str, Dict[str, Any]]:
        """
        扫描素材文件夹，获取所有视频和配音文件
        
        Args:
            material_folders: 素材文件夹信息列表
            
        Returns:
            Dict[str, Dict[str, Any]]: 素材数据字典
        """
        # 导入解析快捷方式的函数
        from src.utils.file_utils import resolve_shortcut
        
        material_data = {}
        
        # 计算每个文件夹的扫描进度
        progress_per_folder = 4.0 / len(material_folders) if material_folders else 0
        
        # 遍历每个素材文件夹
        for idx, folder_info in enumerate(material_folders):
            folder_path = folder_info.get("path", "")
            folder_name = folder_info.get("name", os.path.basename(folder_path) if folder_path else "未命名")
            extract_mode = folder_info.get("extract_mode", "single_video")
            
            if not folder_path or not os.path.exists(folder_path):
                logger.warning(f"素材文件夹不存在: {folder_path}")
                continue
                
            self.report_progress(f"扫描素材文件夹: {folder_name}", 1 + progress_per_folder * idx)
            
            # 检查是否是多视频拼接模式
            if extract_mode == "multi_video":
                # 多视频拼接模式：直接将素材文件夹作为一个场景
                logger.info(f"使用多视频拼接模式处理素材: {folder_path}")
                
                # 初始化场景数据
                segment_key = f"01_{folder_name}"
                material_data[segment_key] = {
                    "videos": [],
                    "audios": [],
                    "path": folder_path,
                    "segment_index": 0,  # 存储段落索引，用于排序
                    "parent_folder": folder_name,  # 记录所属父文件夹
                    "is_shortcut": False,  # 记录是否为快捷方式
                    "original_path": folder_path,  # 记录原始路径
                    "display_name": folder_name,  # 用于显示的名称
                    "extract_mode": "multi_video"  # 标记为多视频拼接模式
                }
                
                # 扫描视频和配音文件夹
                self._scan_media_folder(folder_path, segment_key, material_data)
                
            else:
                # 单视频模式：检查是否有子文件夹
                logger.info(f"使用单视频模式处理素材: {folder_path}")
                
                # 获取所有子文件夹，包括普通文件夹和快捷方式
                sub_folders = []
                
                try:
                    # 遍历文件夹中的所有项目
                    for item in os.listdir(folder_path):
                        # 确保文件名是正确的字符串格式
                        if isinstance(item, bytes):
                            try:
                                item = item.decode('utf-8')
                            except UnicodeDecodeError:
                                try:
                                    item = item.decode('gbk')
                                except UnicodeDecodeError:
                                    logger.error(f"无法解码文件名: {item}")
                                    continue
                        
                        item_path = os.path.join(folder_path, item)
                        is_shortcut = False
                        actual_path = item_path
                        
                        # 检查是否是快捷方式
                        if item.lower().endswith('.lnk'):
                            logger.debug(f"发现可能的快捷方式: {item_path}")
                            shortcut_target = resolve_shortcut(item_path)
                            if shortcut_target and os.path.isdir(shortcut_target):
                                actual_path = shortcut_target
                                is_shortcut = True
                                logger.info(f"解析快捷方式成功: {item_path} -> {actual_path}")
                            else:
                                logger.warning(f"无法解析快捷方式或目标不是目录: {item_path}")
                                continue
                                
                        # 检查是否是文件夹
                        if os.path.isdir(actual_path):
                            # 检查是否有视频或配音子文件夹
                            has_video = os.path.exists(os.path.join(actual_path, "视频"))
                            has_audio = os.path.exists(os.path.join(actual_path, "配音"))
                            
                            # 检查是否有视频快捷方式
                            if not has_video:
                                video_shortcut_paths = [
                                    os.path.join(actual_path, "视频 - 快捷方式.lnk"),
                                    os.path.join(actual_path, "视频.lnk"),
                                    os.path.join(actual_path, "视频快捷方式.lnk")
                                ]
                                
                                for shortcut_path in video_shortcut_paths:
                                    if os.path.exists(shortcut_path):
                                        has_video = True
                                        break
                                        
                                # 如果仍未找到，尝试搜索包含"视频"的所有.lnk文件
                                if not has_video:
                                    try:
                                        for sub_item in os.listdir(actual_path):
                                            # 确保文件名是正确的字符串格式
                                            if isinstance(sub_item, bytes):
                                                try:
                                                    sub_item = sub_item.decode('utf-8')
                                                except UnicodeDecodeError:
                                                    try:
                                                        sub_item = sub_item.decode('gbk')
                                                    except UnicodeDecodeError:
                                                        logger.error(f"无法解码文件名: {sub_item}")
                                                        continue
                                            
                                            if sub_item.lower().endswith('.lnk') and "视频" in sub_item:
                                                has_video = True
                                                break
                                    except Exception as e:
                                        logger.error(f"搜索视频快捷方式时出错: {str(e)}")
                            
                            # 检查是否有配音快捷方式
                            if not has_audio:
                                audio_shortcut_paths = [
                                    os.path.join(actual_path, "配音 - 快捷方式.lnk"),
                                    os.path.join(actual_path, "配音.lnk"),
                                    os.path.join(actual_path, "配音快捷方式.lnk")
                                ]
                                
                                for shortcut_path in audio_shortcut_paths:
                                    if os.path.exists(shortcut_path):
                                        has_audio = True
                                        break
                                        
                                # 如果仍未找到，尝试搜索包含"配音"的所有.lnk文件
                                if not has_audio:
                                    try:
                                        for sub_item in os.listdir(actual_path):
                                            # 确保文件名是正确的字符串格式
                                            if isinstance(sub_item, bytes):
                                                try:
                                                    sub_item = sub_item.decode('utf-8')
                                                except UnicodeDecodeError:
                                                    try:
                                                        sub_item = sub_item.decode('gbk')
                                                    except UnicodeDecodeError:
                                                        logger.error(f"无法解码文件名: {sub_item}")
                                                        continue
                                            
                                            if sub_item.lower().endswith('.lnk') and "配音" in sub_item:
                                                has_audio = True
                                                break
                                    except Exception as e:
                                        logger.error(f"搜索配音快捷方式时出错: {str(e)}")
                            
                            # 如果有视频或配音子文件夹，则添加到子文件夹列表
                            if has_video or has_audio:
                                sub_folders.append({
                                    "name": item,
                                    "path": actual_path,
                                    "is_shortcut": is_shortcut,
                                    "original_path": item_path
                                })
                except Exception as e:
                    logger.error(f"扫描子文件夹时出错: {str(e)}")
                    continue
                
                # 如果没有找到子文件夹，则直接使用当前文件夹
                if not sub_folders:
                    logger.info(f"未找到有效的子文件夹，直接使用当前文件夹: {folder_path}")
                    
                    # 初始化场景数据
                    segment_key = f"01_{folder_name}"
                    material_data[segment_key] = {
                        "videos": [],
                        "audios": [],
                        "path": folder_path,
                        "segment_index": 0,
                        "parent_folder": folder_name,
                        "is_shortcut": False,
                        "original_path": folder_path,
                        "display_name": folder_name
                    }
                    
                    # 扫描视频和配音文件夹
                    self._scan_media_folder(folder_path, segment_key, material_data)
                else:
                    # 按名称排序子文件夹
                    sub_folders.sort(key=lambda x: x["name"])
                    
                    # 处理每个子文件夹
                    for sub_idx, sub_folder_info in enumerate(sub_folders):
                        sub_path = sub_folder_info["path"]
                        sub_name = sub_folder_info["name"]
                        
                        if sub_folder_info["is_shortcut"]:
                            # 移除.lnk后缀，以便更好的显示
                            if sub_name.lower().endswith('.lnk'):
                                sub_name = sub_name[:-4]
                            sub_display_name = f"{sub_name} (快捷方式)"
                        else:
                            sub_display_name = sub_name
                        
                        self.report_progress(
                            f"扫描段落 {sub_idx+1}/{len(sub_folders)}: {sub_display_name}", 
                            1 + progress_per_folder * idx + (progress_per_folder * sub_idx / len(sub_folders))
                        )
                        
                        # 使用顺序编号作为键，确保段落按顺序排列
                        segment_key = f"{sub_idx+1:02d}_{sub_name}"
                        
                        # 初始化段落数据
                        material_data[segment_key] = {
                            "videos": [],
                            "audios": [],
                            "path": sub_path,
                            "segment_index": sub_idx,  # 存储段落索引，用于排序
                            "parent_folder": folder_name,  # 记录所属父文件夹
                            "is_shortcut": sub_folder_info["is_shortcut"],  # 记录是否为快捷方式
                            "original_path": sub_folder_info["original_path"],  # 记录原始快捷方式路径
                            "display_name": sub_display_name  # 用于显示的名称
                        }
                        
                        try:
                            # 扫描视频文件夹
                            self._scan_media_folder(sub_path, segment_key, material_data)
                        except Exception as e:
                            logger.error(f"扫描段落 {sub_display_name} 时出错: {str(e)}")
        
        return material_data
    
    def _scan_media_folder(self, folder_path: str, folder_key: str, material_data: Dict[str, Dict[str, Any]]):
        """
        扫描指定文件夹的媒体文件
        
        Args:
            folder_path: 文件夹路径
            folder_key: 素材数据字典中的键
            material_data: 素材数据字典
        """
        # 导入解析快捷方式的函数
        from src.utils.file_utils import resolve_shortcut
        
        # 获取扫描模式配置
        fast_scan_mode = self.settings.get("fast_scan_mode", True)
        extreme_fast_mode = self.settings.get("extreme_fast_mode", False)
        
        # 查找视频文件夹，包括处理快捷方式
        video_folder = os.path.join(folder_path, "视频")
        video_folder_paths = [video_folder]
        
        # 检查视频文件夹是否存在，如果不存在则尝试查找快捷方式
        if not os.path.exists(video_folder) or not os.path.isdir(video_folder):
            logger.debug(f"常规视频文件夹不存在，尝试寻找快捷方式: {video_folder}")
            
            # 检查所有可能的命名格式
            video_shortcut_candidates = [
                os.path.join(folder_path, "视频 - 快捷方式.lnk"),
                os.path.join(folder_path, "视频.lnk"),
                os.path.join(folder_path, "视频快捷方式.lnk")
            ]
            
            # 添加更多可能的快捷方式路径
            for item in os.listdir(folder_path) if os.path.exists(folder_path) and os.path.isdir(folder_path) else []:
                if item.lower().endswith('.lnk') and "视频" in item:
                    shortcut_path = os.path.join(folder_path, item)
                    if shortcut_path not in video_shortcut_candidates:
                        video_shortcut_candidates.append(shortcut_path)
            
            # 检查所有候选快捷方式
            for shortcut_path in video_shortcut_candidates:
                if os.path.exists(shortcut_path):
                    logger.info(f"发现视频文件夹快捷方式: {shortcut_path}")
                    target_path = resolve_shortcut(shortcut_path)
                    if target_path and os.path.exists(target_path) and os.path.isdir(target_path):
                        logger.info(f"解析快捷方式成功: {shortcut_path} -> {target_path}")
                        video_folder_paths = [target_path]
                        break
        
        # 特别处理极简扫描模式
        if extreme_fast_mode:
            # 极简扫描模式 - 收集所有文件路径，不计算任何元数据
            video_paths = []
            for video_folder in video_folder_paths:
                if os.path.exists(video_folder) and os.path.isdir(video_folder):
                    logger.info(f"极简模式: 正在扫描文件夹: {video_folder}")
                    for root, _, files in os.walk(video_folder):
                        for file in files:
                            if file.lower().endswith((".mp4", ".avi", ".mov", ".mkv", ".wmv")):
                                video_path = os.path.join(root, file)
                                video_paths.append(video_path)
            
            total_videos = len(video_paths)
            logger.info(f"极简模式: 在文件夹 '{folder_key}' 中找到 {total_videos} 个视频路径")
            
            # 确保video_paths键存在
            if "video_paths" not in material_data[folder_key]:
                material_data[folder_key]["video_paths"] = []
            
            # 保存视频路径列表
            material_data[folder_key]["video_paths"] = video_paths
            
            # 为保持兼容，设置空的videos列表
            material_data[folder_key]["videos"] = []
            
            # 确定当前文件夹的抽取模式
            extract_mode = material_data[folder_key].get("extract_mode", "single_video")
            logger.info(f"极简模式: 文件夹 '{folder_key}' 使用抽取模式: {extract_mode}")
            
            # 初始化预选列表为空
            material_data[folder_key]["preselected_multi_videos"] = []
            material_data[folder_key]["preselected_video"] = None
            
            # 确保有视频可供选择
            if video_paths:
                # 随机打乱视频路径列表
                import random
                random.shuffle(video_paths)
                
                if extract_mode == "multi_video":
                    # 多视频模式预选逻辑
                    # 使用全部可用视频，不限制数量，以生成更长的混剪视频
                    selected_videos = video_paths
                    logger.info(f"极简预选模式: 为多视频拼接从{total_videos}个视频中预选全部 {len(selected_videos)} 个视频")
                    
                    # 详细记录预选的视频文件名（最多显示前10个）
                    preview_count = min(10, len(selected_videos))
                    preview_videos = [os.path.basename(p) for p in selected_videos[:preview_count]]
                    preview_str = ", ".join(preview_videos)
                    if len(selected_videos) > preview_count:
                        preview_str += f" 等共{len(selected_videos)}个"
                    logger.info(f"预选视频文件列表（部分）: {preview_str}")
                    
                    # 存储预选的多视频列表
                    material_data[folder_key]["preselected_multi_videos"] = selected_videos
                    
                    # 额外日志记录，确认预选列表长度
                    actual_count = len(material_data[folder_key]["preselected_multi_videos"])
                    logger.info(f"预选多视频列表已保存，实际包含 {actual_count} 个视频")
                else:
                    # 单视频模式预选逻辑
                    selected_video = video_paths[0] if video_paths else None
                    logger.info(f"极简预选模式: 为单视频模式从{total_videos}个视频中预选视频: {os.path.basename(selected_video) if selected_video else '无'}")
                    
                    # 存储预选的单个视频
                    material_data[folder_key]["preselected_video"] = selected_video
            else:
                logger.warning(f"极简模式: 文件夹 '{folder_key}' 中没有找到视频文件，无法进行预选")
        else:
            logger.info(f"非极简模式: 文件夹 '{folder_key}' 使用标准扫描方式")
        
        # 原有的快速扫描模式和标准模式处理
        video_info_list = []
        for video_folder in video_folder_paths:
            if os.path.exists(video_folder) and os.path.isdir(video_folder):
                # 获取所有视频文件
                video_files = []
                for root, _, files in os.walk(video_folder):
                    for file in files:
                        if file.lower().endswith((".mp4", ".avi", ".mov", ".mkv", ".wmv")):
                            video_files.append(os.path.join(root, file))
                
                logger.info(f"在文件夹 '{video_folder}' 中找到 {len(video_files)} 个视频文件")
                
                # 检查是否使用快速扫描模式
                if fast_scan_mode:
                    # 快速扫描模式：只收集文件路径，不读取元数据
                    logger.info(f"使用快速扫描模式，仅收集文件路径信息")
                    for video_file in video_files:
                        # 只保存路径信息，不读取元数据
                        video_info = {
                            "path": video_file,
                            # 使用系统文件信息获取基本元数据
                            "duration": 0,  # 默认0，后续选择时再读取
                            "file_size": os.path.getsize(video_file) if os.path.exists(video_file) else 0,
                            "fast_scan": True  # 标记为快速扫描模式
                        }
                        video_info_list.append(video_info)
                else:
                    # 完整扫描模式：读取每个视频的元数据
                for video_file in video_files:
                    try:
                        video_info = self._get_video_metadata(video_file)
                        if video_info and video_info.get("duration", 0) > 0:
                            video_info_list.append(video_info)
                    except Exception as e:
                        logger.warning(f"分析视频失败: {video_file}, 错误: {str(e)}")
            
        # 保存视频列表
        material_data[folder_key]["videos"] = video_info_list
        logger.info(f"文件夹 '{folder_key}' 中找到 {len(video_info_list)} 个有效视频")
        
        # 为保持兼容，设置空的video_paths列表和预选视频字段
        if "video_paths" not in material_data[folder_key]:
            material_data[folder_key]["video_paths"] = []
        material_data[folder_key]["preselected_video"] = None
        material_data[folder_key]["preselected_multi_videos"] = []
        
        # 查找配音文件夹，包括处理快捷方式
        audio_folder = os.path.join(folder_path, "配音")
        audio_folder_paths = [audio_folder]
        
        # 检查配音文件夹是否存在，如果不存在则尝试查找快捷方式
        if not os.path.exists(audio_folder) or not os.path.isdir(audio_folder):
            logger.debug(f"常规配音文件夹不存在，尝试寻找快捷方式: {audio_folder}")
            
            # 检查所有可能的命名格式
            audio_shortcut_candidates = [
                os.path.join(folder_path, "配音 - 快捷方式.lnk"),
                os.path.join(folder_path, "配音.lnk"),
                os.path.join(folder_path, "配音快捷方式.lnk")
            ]
            
            # 添加更多可能的快捷方式路径
            for item in os.listdir(folder_path) if os.path.exists(folder_path) and os.path.isdir(folder_path) else []:
                if item.lower().endswith('.lnk') and "配音" in item:
                    shortcut_path = os.path.join(folder_path, item)
                    if shortcut_path not in audio_shortcut_candidates:
                        audio_shortcut_candidates.append(shortcut_path)
            
            # 检查所有候选快捷方式
            for shortcut_path in audio_shortcut_candidates:
                if os.path.exists(shortcut_path):
                    logger.info(f"发现配音文件夹快捷方式: {shortcut_path}")
                    target_path = resolve_shortcut(shortcut_path)
                    if target_path and os.path.exists(target_path) and os.path.isdir(target_path):
                        logger.info(f"解析快捷方式成功: {shortcut_path} -> {target_path}")
                        audio_folder_paths = [target_path]
                        break
        
        # 特别处理极简扫描模式
        if extreme_fast_mode:
            # 极简扫描模式 - 收集所有文件路径，不获取任何元数据
            audio_paths = []
            for audio_folder in audio_folder_paths:
                if os.path.exists(audio_folder) and os.path.isdir(audio_folder):
                    logger.info(f"极简模式: 正在扫描配音文件夹: {audio_folder}")
                    for root, _, files in os.walk(audio_folder):
                        for file in files:
                            if file.lower().endswith((".mp3", ".wav", ".aac", ".ogg", ".flac")):
                                audio_path = os.path.join(root, file)
                                audio_paths.append(audio_path)
            
            total_audios = len(audio_paths)
            logger.info(f"极简模式: 在文件夹 '{folder_key}' 中找到 {total_audios} 个音频路径")
            
            # 确保audio_paths键存在
            if "audio_paths" not in material_data[folder_key]:
                material_data[folder_key]["audio_paths"] = []
            
            # 保存音频路径列表
            material_data[folder_key]["audio_paths"] = audio_paths
            
            # 为保持兼容，设置空的audios列表
            material_data[folder_key]["audios"] = []
            
            # 预选一个配音文件
            if audio_paths:
                import random
                preselected_audio = random.choice(audio_paths)
                material_data[folder_key]["preselected_audio"] = preselected_audio
                logger.info(f"极简预选模式: 从{total_audios}个配音中预选配音: {os.path.basename(preselected_audio)}")
            else:
                material_data[folder_key]["preselected_audio"] = None
        else:
            # 处理配音文件夹 - 原有的处理逻辑
        audio_info_list = []
        for audio_folder in audio_folder_paths:
            if os.path.exists(audio_folder) and os.path.isdir(audio_folder):
                # 获取所有音频文件
                audio_files = []
                for root, _, files in os.walk(audio_folder):
                    for file in files:
                        if file.lower().endswith((".mp3", ".wav", ".aac", ".ogg", ".flac")):
                            audio_files.append(os.path.join(root, file))
                
                logger.info(f"在文件夹 '{audio_folder}' 中找到 {len(audio_files)} 个音频文件")
                
                    # 对于音频文件，由于数量较少且读取速度快，始终读取元数据
                for audio_file in audio_files:
                    try:
                        audio_info = self._get_audio_metadata(audio_file)
                        if audio_info and audio_info.get("duration", 0) > 0:
                            audio_info_list.append(audio_info)
                    except Exception as e:
                        logger.warning(f"分析音频失败: {audio_file}, 错误: {str(e)}")
        
        # 保存音频列表
        material_data[folder_key]["audios"] = audio_info_list
        logger.info(f"文件夹 '{folder_key}' 中找到 {len(audio_info_list)} 个有效配音")
    
            # 为保持兼容，设置空的audio_paths列表和预选配音字段
            if "audio_paths" not in material_data[folder_key]:
                material_data[folder_key]["audio_paths"] = []
            material_data[folder_key]["preselected_audio"] = None
        
        # 在_scan_media_folder方法中的最后，确保预选部分的代码逻辑如下（在收集完所有视频后）

        # 极简模式下进行预选处理
        if self.settings.get("extreme_fast_mode", False):
            # 计算当前场景收集到的全部视频路径
            total_video_paths = len(material_data[folder_key]["video_paths"])
            total_audio_paths = len(material_data[folder_key]["audio_paths"])
            
            # 记录日志
            logger.info(f"极简模式：共收集到 {total_video_paths} 个视频文件路径，开始预选")
            
            # 首先获取配音时长(如果有配音文件)，作为选择视频的参考
                        audio_duration = 0
            if material_data[folder_key]["audio_paths"]:
                # 随机选择一个配音文件
                audio_path = random.choice(material_data[folder_key]["audio_paths"])
                material_data[folder_key]["preselected_audio"] = audio_path
                
                # 尝试获取配音时长
                try:
                    audio_info = self._get_audio_metadata(audio_path)
                    if audio_info and audio_info.get("duration", 0) > 0:
                        audio_duration = audio_info.get("duration", 0)
                        logger.info(f"预选配音文件: {os.path.basename(audio_path)}, 时长: {audio_duration:.2f}秒")
                    else:
                        logger.warning(f"无法获取配音时长: {os.path.basename(audio_path)}")
            except Exception as e:
                    logger.warning(f"获取配音时长失败: {str(e)}")
            
            # 根据抽取模式进行视频预选
            extract_mode = material_data[folder_key].get("extract_mode", "single_video")
            if extract_mode == "single_video":
                # 单视频模式：根据配音时长选择合适的视频
                if material_data[folder_key]["video_paths"]:
                    # 随机打乱视频列表
                    video_paths = material_data[folder_key]["video_paths"].copy()
                    random.shuffle(video_paths)
                    
                    selected_video = None
                    
                    # 如果知道配音时长，尝试找到合适时长的视频
                    if audio_duration > 0:
                        # 尝试查找时长接近但略长于配音的视频
                        suitable_videos = []
                        for video_path in video_paths[:min(20, len(video_paths))]:  # 只检查前20个，避免过多元数据操作
                            try:
                                video_info = self._get_video_metadata(video_path)
                                if video_info and video_info.get("duration", 0) >= audio_duration:
                                    # 找到合适的视频
                                    suitable_videos.append((video_path, video_info.get("duration", 0)))
            except Exception as e:
                                logger.debug(f"获取视频元数据失败: {str(e)}")
                        
                        # 如果找到合适的视频，选择时长最接近配音的
                        if suitable_videos:
                            # 按时长差异排序
                            suitable_videos.sort(key=lambda x: abs(x[1] - audio_duration))
                            selected_video = suitable_videos[0][0]
                            logger.info(f"根据配音时长({audio_duration:.2f}秒)选择了最佳匹配视频: {os.path.basename(selected_video)}, 时长: {suitable_videos[0][1]:.2f}秒")
                    
                    # 如果没有找到合适的视频或不知道配音时长，随机选择一个
                    if not selected_video:
                        selected_video = random.choice(video_paths)
                        logger.info(f"随机选择单个视频: {os.path.basename(selected_video)}")
                    
                    material_data[folder_key]["preselected_video"] = selected_video
                    
                    # 添加详细日志，显示预选的视频文件名
                    logger.info(f"极简预选模式：为单视频模式预选了视频: {os.path.basename(selected_video)}")
                    else:
                # 多视频模式：根据配音时长选择多个视频用于拼接
                if material_data[folder_key]["video_paths"]:
                    # 随机打乱视频路径顺序
                    shuffled_paths = material_data[folder_key]["video_paths"].copy()
                    random.shuffle(shuffled_paths)
                    
                    # 估算每个视频的平均时长（如无配音则假设15秒）
                    avg_video_duration = 15  # 默认假设平均15秒
                    
                    # 根据配音时长确定需要的视频数量
                    count = 0
                    if audio_duration > 0:
                        # 先尝试获取几个视频的实际时长来计算平均值
                        sample_count = min(5, len(shuffled_paths))
                        sample_durations = []
                        
                        for i in range(sample_count):
                            try:
                                video_info = self._get_video_metadata(shuffled_paths[i])
                                if video_info and video_info.get("duration", 0) > 0:
                                    sample_durations.append(video_info.get("duration", 0))
                except Exception as e:
                                logger.debug(f"获取视频元数据失败: {str(e)}")
                        
                        # 计算平均时长
                        if sample_durations:
                            avg_video_duration = sum(sample_durations) / len(sample_durations)
                            logger.info(f"样本视频平均时长: {avg_video_duration:.2f}秒")
                        
                        # 计算需要的视频数量(向上取整，确保总时长超过配音)
                        import math
                        required_videos = math.ceil(audio_duration / avg_video_duration)
                        
                        # 确保至少选择2个视频用于混剪，最多30个视频
                        required_videos = max(2, min(30, required_videos))
                        logger.info(f"根据配音时长({audio_duration:.2f}秒)和估算平均视频时长({avg_video_duration:.2f}秒)，计划选择约 {required_videos} 个视频")
                        
                        # 选择指定数量的视频
                        count = min(required_videos, len(shuffled_paths))
                    else:
                        # 如果不知道配音时长，则使用默认逻辑选择视频数量
                        if total_video_paths <= 10:
                            # 如果视频很少，全部选择
                            count = total_video_paths
                        elif total_video_paths <= 100:
                            # 中等数量的视频，选择更多
                            count = min(20, total_video_paths)
                else:
                            # 大量视频时，选择更多样本确保多样性
                            count = min(50, total_video_paths)
                    
                    logger.info(f"极简预选模式：从 {total_video_paths} 个视频中为多视频模式预选 {count} 个视频")
                    
                    # 确保至少选择一定数量的视频
                    count = max(count, min(10, total_video_paths))
                    preselected_videos = shuffled_paths[:count]
                    material_data[folder_key]["preselected_multi_videos"] = preselected_videos
                    
                    # 添加详细日志，显示前几个预选的视频文件名
                    preview_count = min(5, len(preselected_videos))
                    preview_videos = [os.path.basename(p) for p in preselected_videos[:preview_count]]
                    preview_str = ", ".join(preview_videos)
                    if len(preselected_videos) > preview_count:
                        preview_str += f" 等共{len(preselected_videos)}个"
                    logger.info(f"极简预选模式：为多视频模式预选了视频: {preview_str}")
                    
                    # 验证预选结果
                    if len(material_data[folder_key]["preselected_multi_videos"]) > 0:
                        logger.info(f"成功为多视频模式预选 {len(material_data[folder_key]['preselected_multi_videos'])} 个视频")
                    else:
                        logger.warning("多视频预选结果为空，可能存在问题")
            
            # 预选音频文件(如果之前没选)
            if not material_data[folder_key].get("preselected_audio") and material_data[folder_key]["audio_paths"]:
                preselected_audio = random.choice(material_data[folder_key]["audio_paths"])
                material_data[folder_key]["preselected_audio"] = preselected_audio
                logger.info(f"极简预选模式：预选了音频: {os.path.basename(preselected_audio)}")
            
            # 记录最终预选结果
            if extract_mode == "multi_video":
                logger.info(f"极简预选模式：场景 '{folder_key}' 多视频拼接模式预选完成，共选择 {len(material_data[folder_key].get('preselected_multi_videos', []))} 个视频")
                    else:
                if material_data[folder_key].get("preselected_video"):
                    logger.info(f"极简预选模式：场景 '{folder_key}' 单视频模式预选完成，选择视频: {os.path.basename(material_data[folder_key]['preselected_video'])}")
            else:
                    logger.warning(f"极简预选模式：场景 '{folder_key}' 单视频模式预选失败，没有找到合适的视频")
        
        # 以下是非极简模式的处理逻辑
        # 初始化变量
        selected_videos = []
        audio_path = None
        extract_mode = None
        
        # 查找所有多视频模式的段落
        multi_video_segments = []
        for key, data in material_data.items():
            if data.get("extract_mode") == "multi_video":
                multi_video_segments.append((key, data))
        
        # 查找所有配音
        for segment_key, data in material_data.items():
            if data.get("audio") and not audio_path:
                audio_path = data.get("audio")
                logger.info(f"使用音频: {os.path.basename(audio_path)}")
        
        # 确保输出目录存在
        output_dir = os.path.dirname(output_path)
        if output_dir and not os.path.exists(output_dir):
            try:
                os.makedirs(output_dir, exist_ok=True)
                logger.info(f"已创建输出目录: {output_dir}")
        except Exception as e:
                logger.error(f"创建输出目录失败: {str(e)}")
                raise IOError(f"无法创建输出目录: {str(e)}")
        
        # 根据素材选择处理模式
        if multi_video_segments:
            # 如果有多视频模式的段落，选择第一个
            segment_key, segment_data = multi_video_segments[0]
            extract_mode = "multi_video"
            logger.info(f"使用多视频模式，段落: {segment_key}")
            
            # 随机打乱视频
            video_list = segment_data.get("videos", [])
            if not video_list and segment_data.get("video_paths", []):
                # 如果是极简模式收集的路径，转换为视频列表
                for path in segment_data.get("video_paths", []):
                    video_list.append({"path": path, "duration": 0, "fast_scan": True})
            
            if not video_list:
                logger.error(f"段落 {segment_key} 中没有找到视频文件")
                raise ValueError(f"段落 {segment_key} 中没有找到视频文件")
            
            # 根据mode选择处理方式
            video_mode = self.settings.get("video_mode", "")
            
            # 随机选择一组视频用于拼接
            if len(video_list) > 1:
                random.shuffle(video_list)
                # 不再限制视频数量，使用全部可用视频
                logger.info(f"使用全部 {len(video_list)} 个可用视频，以生成更长的混剪视频")
            
            # 提取视频路径
            valid_videos_count = 0
            invalid_videos_count = 0
            for video_info in video_list:
                # 对于快速扫描模式，按需加载元数据
                if video_info.get("fast_scan", False) and not extreme_fast_mode:
                    try:
                        video_info = self._get_lazy_video_metadata(video_info)
                except Exception as e:
                        logger.warning(f"获取视频元数据失败: {str(e)}")
                        video_info = None
                
                if video_info and "path" in video_info:
                    video_path = video_info.get("path", "")
                    # 验证视频文件
                    if os.path.exists(video_path) and os.path.getsize(video_path) > 1000:
                        selected_videos.append(video_path)
                        valid_videos_count += 1
                    else:
                        logger.warning(f"跳过无效视频: {video_path}")
                        invalid_videos_count += 1
            
            logger.info(f"选择了 {valid_videos_count} 个有效视频用于拼接, 跳过 {invalid_videos_count} 个无效视频")
            
            if len(selected_videos) == 0:
                logger.error("没有找到有效的视频文件可用于拼接")
                raise ValueError("没有有效的视频文件可用于拼接")
            
            else:
            # 如果没有多视频模式的段落，使用单视频模式
            extract_mode = "single_video"
            logger.info("使用单视频模式")
            
            # 查找所有视频
            all_videos = []
            for segment_key, data in material_data.items():
                video_list = data.get("videos", [])
                if not video_list and data.get("video_paths", []):
                    # 如果是极简模式收集的路径，转换为视频列表
                    for path in data.get("video_paths", []):
                        video_list.append({"path": path, "duration": 0, "fast_scan": True})
                
                # 添加到总列表
                all_videos.extend(video_list)
            
            if not all_videos:
                logger.error("没有找到任何视频文件")
                raise ValueError("没有找到任何视频文件")
            
            # 随机选择一个视频
            selected_video_info = None
            attempts = 0
            max_attempts = min(10, len(all_videos))
            
            while attempts < max_attempts and not selected_video_info:
                video_info = random.choice(all_videos)
                
                # 对于快速扫描模式，加载元数据
                if video_info.get("fast_scan", False) and not extreme_fast_mode:
                    try:
                        video_info = self._get_lazy_video_metadata(video_info)
        except Exception as e:
                        logger.warning(f"获取视频元数据失败: {str(e)}")
                        video_info = None
                
                # 验证视频文件
                if video_info and "path" in video_info:
                    video_path = video_info.get("path", "")
                    if os.path.exists(video_path) and os.path.getsize(video_path) > 1000:
                        selected_video_info = video_info
        else:
                        logger.warning(f"跳过无效视频: {video_path}")
                
                attempts += 1
            
            # 添加到选择列表
            if selected_video_info:
                selected_videos.append(selected_video_info.get("path", ""))
                logger.info(f"选择了视频文件: {os.path.basename(selected_video_info.get('path', ''))}")
        else:
                logger.error("没有找到有效的视频文件")
                raise ValueError("没有找到有效的视频文件")
        
        # 处理所选视频
        try:
            # 根据模式处理
            if extract_mode == "multi_video" and len(selected_videos) > 1:
                # 多视频模式 - 拼接多个视频
                self.report_progress("正在拼接多个视频...", progress_start + 30)
                
                # 获取音频时长作为目标时长
                target_duration = None
                if audio_path:
                    try:
                        audio_info = self._get_audio_metadata(audio_path)
                        if audio_info:
                            target_duration = audio_info.get("duration", 0)
                            logger.info(f"使用音频时长作为目标时长: {target_duration:.2f}秒")
                except Exception as e:
                        logger.warning(f"获取音频时长失败: {str(e)}")
                
                # 使用FFmpeg拼接视频
                success = self._concat_videos_with_ffmpeg(
                    selected_videos, 
                    audio_path, 
                    output_path, 
                    target_duration
                )
                
                if not success:
                    logger.error("使用FFmpeg拼接视频失败")
                    
                    # 尝试降级到单视频模式
                    if len(selected_videos) > 0:
                        logger.info("尝试降级到单视频模式作为备选方案")
                        extract_mode = "single_video"
                        else:
                        raise RuntimeError("使用FFmpeg拼接视频失败")
                
            # 单视频模式处理（如果没有多个视频或多视频处理失败）
            if extract_mode == "single_video" or len(selected_videos) <= 1:
                # 单视频模式
                self.report_progress("正在处理单个视频...", progress_start + 30)
                
                # 获取音频时长作为目标时长
                target_duration = None
                if audio_path:
                    try:
                        audio_info = self._get_audio_metadata(audio_path)
                        if audio_info:
                            target_duration = audio_info.get("duration", 0)
                            logger.info(f"使用音频时长作为目标时长: {target_duration:.2f}秒")
                except Exception as e:
                        logger.warning(f"获取音频时长失败: {str(e)}")
                
                # 使用FFmpeg处理单个视频
                if not selected_videos:
                    logger.error("没有有效的视频文件可用于单视频处理")
                    raise ValueError("没有有效的视频文件可用于单视频处理")
                
                # 确认视频文件存在且有效
                if not os.path.exists(selected_videos[0]):
                    logger.error(f"选定的视频文件不存在: {selected_videos[0]}")
                    raise FileNotFoundError(f"视频文件不存在: {selected_videos[0]}")
                
                success = self._process_single_video_with_ffmpeg(
                    selected_videos[0], 
                    audio_path, 
                    output_path, 
                    target_duration
                )
            
                if not success:
                    logger.error("使用FFmpeg处理视频失败")
                    raise RuntimeError("使用FFmpeg处理视频失败")
            
            # 处理背景音乐
                if bgm_path and os.path.exists(bgm_path):
                self.report_progress("正在添加背景音乐...", progress_start + 80)
                try:
                    self._add_bgm_to_video(output_path, bgm_path)
                    logger.info("成功添加背景音乐")
                        except Exception as e:
                    logger.warning(f"添加背景音乐失败: {str(e)}")
            
            # 添加水印
            if self.settings.get("add_watermark", False):
                self.report_progress("正在添加水印...", progress_start + 90)
                try:
                    watermark_path = self.settings.get("watermark_path", "")
                    if watermark_path and os.path.exists(watermark_path):
                        self._add_watermark_to_video(output_path, watermark_path)
                                logger.info("成功添加水印")
                            except Exception as e:
                    logger.warning(f"添加水印失败: {str(e)}")
            
            # 验证最终输出文件
            if os.path.exists(output_path) and os.path.getsize(output_path) > 1000:
                self.report_progress("视频处理完成", progress_end)
                return output_path
            else:
                logger.error(f"输出文件不存在或无效: {output_path}")
                raise RuntimeError(f"生成的视频文件无效: {output_path}")
            
                            except Exception as e:
            logger.error(f"处理视频时出错: {str(e)}")
            # 更新进度至结束
            self.report_progress(f"视频处理失败: {str(e)}", progress_end)
            raise

    def _create_temp_file(self, prefix="temp", suffix=".tmp"):
        """
        创建临时文件
        
        Args:
            prefix: 文件名前缀
            suffix: 文件扩展名
            
        Returns:
            str: 临时文件路径
        """
        try:
            # 确保临时目录存在
            temp_dir = self.settings.get("temp_dir", tempfile.gettempdir())
            os.makedirs(temp_dir, exist_ok=True)
            
            # 创建唯一文件名
            file_name = f"{prefix}_{uuid.uuid4().hex}{suffix}"
            file_path = os.path.join(temp_dir, file_name)
            
            # 记录创建的临时文件，用于后续清理
            self.temp_files.append(file_path)
            
            return file_path
            except Exception as e:
            logger.error(f"创建临时文件失败: {str(e)}")
            # 回退到系统临时目录
            fallback_file = os.path.join(tempfile.gettempdir(), f"{prefix}_{uuid.uuid4().hex}{suffix}")
            logger.info(f"使用系统临时目录创建临时文件: {fallback_file}")
            return fallback_file
